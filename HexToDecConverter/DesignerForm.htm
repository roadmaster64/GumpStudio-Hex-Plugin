<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
	<head>
	<style type="text/css">span.black {color: Black}</style>
	<style type="text/css">span.teal {color: Teal}</style><!-- override/virtual/const/static -->
    <style type="text/css">span.blue {color: Blue}</style><!-- void/bool/int (any return type) -->
    <style type="text/css">span.lime {color: Lime}</style>
    <style type="text/css">span.liteblue {color: #0066ff}</style><!-- public/private/protected -->
    <style type="text/css">span.larger {font-size:larger}</style>
    <style type="text/css">span.small {font-size:small}</style>
		<title>DesignerForm : System.Windows.Forms.Form - Class Overview</title>
	</head>
	<body bgcolor="white" style="font-family: Courier New" text="#000000" link="#000000" vlink="#000000" alink="#808080">
	<h2 style="color:Black">DesignerForm <span class="small">(class overview)</span></h2>
	
	Methods<br /><br />
	
	 <b>ctor </b><span class="liteblue">public</span> <span class="blue"><b>DesignerForm() </b></span>: base()<br />
	<span class="liteblue">protected</span> <span class="teal"><b>override</b></span> <span class="blue"><b>void</b></span> <b>Dispose(<span class="blue">bool</span> disposing)</b> "AutoGenerated by Windows for the disposal of components"<br />
	<span class="liteblue">private</span> <b>InitializeComponent()</b> "contains the components that create the Form"<br />

	
	
	</body>
</html>

<!--#region " Windows Form Designer generated code " 
     
 
    
    //Hook Events for plugins 
    public event HookPreRenderEventHandler HookPreRender; 
    public delegate void HookPreRenderEventHandler(Bitmap Target); 
    //fires before Elements are rendered to the canvas 
    public event HookPostRenderEventHandler HookPostRender; 
    public delegate void HookPostRenderEventHandler(Bitmap Target); 
    //fires after Elements are rendered 
    public event HookKeyDownEventHandler HookKeyDown; 
    public delegate void HookKeyDownEventHandler(object sender, ref System.Windows.Forms.KeyEventArgs e); 
    //Public Event ElementSelected(ByVal Element As BaseElement) 
    //Public Event ElementClicked(ByVal Element As BaseElement, ByVal X As Integer, ByVal Y As Integer) 
    //Public Event ElementResized(ByVal Element As BaseElement) 
    
    
    #region "Rendering" 
    
    protected void Render(Graphics Target) 
    { 
        Graphics g = Graphics.FromImage(Canvas); 
        if (!PluginClearsCanvas) 
            g.Clear(Color.Black); 
        if (HookPreRender != null) { 
            HookPreRender(Canvas); 
        } 
        if (ShowPage0 && (!object.ReferenceEquals(ElementStack, Stacks(0)))) { 
            ((BaseElement)Stacks(0)).Render(g); 
        } 
        ElementStack.Render(g); 
        foreach (object o in ElementStack.GetElements) { 
            //draw selection boxes 
            BaseElement e = (BaseElement)o; 
            if (e.Selected && (!object.ReferenceEquals(e, ActiveElement))) { 
                e.DrawBoundingBox(g, false); 
            } 
        } 
        if ((ActiveElement != null)) { 
            //draw active element selection box 
            ActiveElement.DrawBoundingBox(g, true); 
        } 
        if (ShowSelectionRect) { 
            //draw the selection rectangle 
            g.FillRectangle(SelBG, SelectionRect); 
            g.DrawRectangle(SelFG, SelectionRect); 
        } 
        if (HookPostRender != null) { 
            HookPostRender(Canvas); 
        } 
        g.Dispose(); 
        Target.DrawImage(Canvas, 0, 0); 
        //Threading.Thread.Sleep(1) 
    } 
    
    protected void DrawBoundingBox(Graphics Target, BaseElement Element) 
    { 
        Rectangle r = Element.Bounds; 
        Target.DrawRectangle(Pens.Red, r); 
        r.Offset(1, 1); 
        Target.DrawRectangle(Pens.Black, r); 
    } 
    
    private void picCanvas_Paint(object sender, System.Windows.Forms.PaintEventArgs e) 
    { 
        Render(e.Graphics); 
    } 
    #endregion 
    
    #region "Mouse Capture" 
    
    private void picCanvas_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e) 
    { 
        CanvasFocus.Focus(); 
        Point MouseLoc = new Point(e.X, e.Y); 
        mAnchor = MouseLoc; 
        BaseElement ClickedElement = ElementStack.GetElementFromPoint(MouseLoc); 
        //Get the element that was clicked on 
        if ((ActiveElement != null) && ActiveElement.HitTest(MouseLoc) != MoveModeType.None) 
            ClickedElement = ActiveElement; 
        if ((ClickedElement != null)) { 
            //if an element was actually clicked on 
            MoveMode = ClickedElement.HitTest(MouseLoc); 
            //determine where on the element it was clicked 
            
            if ((ActiveElement != null) && ActiveElement.HitTest(MouseLoc) == MoveModeType.None) { 
                //if the click was inside the bounds of the active element we want to ignore it 
                if (ClickedElement.Selected) { 
                    //if the clicked element was already selected we just want to make it active 
                    if ((bool)Control.ModifierKeys & Keys.Control) { 
                        ClickedElement.Selected = false; 
                    } 
                    else { 
                        SetActiveElement(ClickedElement, false); 
                    } 
                } 
                else { 
                    //if it wasn't selected then we want to select it, but deselect all the other elements, unless control was down 
                    SetActiveElement(ClickedElement, !(bool)Control.ModifierKeys & Keys.Control); 
                } 
            } 
            else if (ActiveElement == null) { 
                //If there is no active item, but they clicked on a selected item, make it active without deselecting the others 
                SetActiveElement(ClickedElement, false); 
            } 
            else if (ActiveElement != null) { 
                if ((bool)Control.ModifierKeys & Keys.Control) { 
                    ActiveElement.Selected = false; 
                    ArrayList Sel = ElementStack.GetSelectedElements; 
                    if (Sel.Count > 0) { 
                        SetActiveElement((BaseElement)Sel(0), false); 
                    } 
                    else { 
                        SetActiveElement(null, true); 
                        MoveMode = MoveModeType.None; 
                    } 
                } 
            } 
        } 
        else { 
            MoveMode = MoveModeType.None; 
            if ((bool)e.Button & MouseButtons.Left) 
                SetActiveElement(null, !(bool)Control.ModifierKeys & Keys.Control); 
            //only check clear based on control if it was the left button 
        } 
        
        picCanvas.Invalidate(); 
        
        LastPos = MouseLoc; 
        if ((ActiveElement != null)) { 
            //Find the offset of the anchorpoint from the Top left of the activelement 
            mAnchorOffset.Width = ActiveElement.X - MouseLoc.X; 
            mAnchorOffset.Height = ActiveElement.Y - MouseLoc.Y; 
        } 
        ElementChanged = false; 
        MoveCount = 0; 
    } 
    
    private void picCanvas_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e) 
    { 
        Point MouseLoc = new Point(e.X, e.Y); 
        int mcX; 
        int mcY; 
        mcX = MouseLoc.X - LastPos.X; 
        mcY = MouseLoc.Y - LastPos.Y; 
        BaseElement HoverElement = ElementStack.GetElementFromPoint(MouseLoc); 
        //find the element we are hoving over 
        if ((ActiveElement != null) && ActiveElement.HitTest(MouseLoc) != MoveModeType.None) 
            HoverElement = ActiveElement; 
        //if we are hovering over the active element, even if it is covered by another, it overides hoverelement 
        
        if (MoveMode == MoveModeType.Move) { 
            MouseLoc.Offset(mAnchorOffset.Width, mAnchorOffset.Height); 
        } 
        
        //let the plugins get a chance to do thier thing 
        Plugins.MouseMoveHookEventArgs Args = new Plugins.MouseMoveHookEventArgs(); 
        Args.Keys = Control.ModifierKeys; 
        Args.MouseButtons = e.Button; 
        Args.MouseLocation = MouseLoc; 
        Args.MoveMode = MoveMode; 
        foreach (object o in LoadedPlugins) { 
            Plugins.BasePlugin Plugin = (Plugins.BasePlugin)o; 
            Plugin.MouseMoveHook(Args); 
            MouseLoc = Args.MouseLocation; 
        } 
        
        
        if (MoveMode == MoveModeType.None && Math.Abs(mcX) > 0 && Math.Abs(mcY) > 0) 
            MoveMode = MoveModeType.SelectionBox; 
        if (e.Button == MouseButtons.Left) { 
            MoveCount += 1; 
            if (MoveCount > 100) 
                MoveCount = 2; 
            Cursor.Clip = picCanvas.RectangleToScreen(new Rectangle(0, 0, picCanvas.Width, picCanvas.Height)); 
            //lock the cursor to the canvas 
            if (MoveMode != MoveModeType.None) { 
                //choose a cursor based on the movemode 
                switch (MoveMode) { 
                    case MoveModeType.Move: 
                        this.Cursor = Cursors.SizeAll; 
                        break; 
                    case MoveModeType.ResizeTopLeft: 
                    case MoveModeType.ResizeBottomRight: 
                        this.Cursor = Cursors.SizeNWSE; 
                        break; 
                    case MoveModeType.ResizeTopRight: 
                    case MoveModeType.ResizeBottomLeft: 
                        this.Cursor = Cursors.SizeNESW; 
                        break; 
                    case MoveModeType.ResizeTop: 
                    case MoveModeType.ResizeBottom: 
                        this.Cursor = Cursors.SizeNS; 
                        break; 
                    case MoveModeType.ResizeLeft: 
                    case MoveModeType.ResizeRight: 
                        this.Cursor = Cursors.SizeWE; 
                        break; 
                    default: 
                        this.Cursor = Cursors.Default; 
                        break; 
                } 
                if (MoveCount >= 2) 
                    ElementChanged = true; 
            } 
            switch (MoveMode) { 
                case MoveModeType.SelectionBox: 
                    Size SelSize = new Size(MouseLoc.X - mAnchor.X, MouseLoc.Y - mAnchor.Y); 
                    SelectionRect = GetPositiveRect(new Rectangle(mAnchor, SelSize)); 
                    ShowSelectionRect = true; 
                    picCanvas.Invalidate(); 
                    break; 
                case MoveModeType.Move: 
                    Point OldLoc = ActiveElement.Location; 
                    ActiveElement.Location = MouseLoc; 
                    int cX = ActiveElement.X - OldLoc.X; 
                    int cY = ActiveElement.Y - OldLoc.Y; 
                    foreach (object o in ElementStack.GetSelectedElements) { 
                        BaseElement Element = (BaseElement)o; 
                        if ((!object.ReferenceEquals(Element, ActiveElement))) { 
                            Point TempLoc = Element.Location; 
                            TempLoc.Offset(cX, cY); 
                            Element.Location = TempLoc; 
                        } 
                    } 

                    picCanvas.Invalidate(); 
                    break; 
                case MoveModeType.ResizeBottomRight: 
                    MouseLoc.Offset(-3, -3); 
                    Size NewSize = ActiveElement.Size; 
                    NewSize.Width = MouseLoc.X - ActiveElement.X; 
                    NewSize.Height = MouseLoc.Y - ActiveElement.Y; 
                    if (NewSize.Width < 1) 
                        NewSize.Width = 1; 

                    if (NewSize.Height < 1) 
                        NewSize.Height = 1; 

                    ActiveElement.Size = NewSize; 
                    picCanvas.Invalidate(); 
                    break; 
                case MoveModeType.ResizeRight: 
                    MouseLoc.Offset(-3, 0); 
                    Size NewSize = ActiveElement.Size; 
                    NewSize.Width = MouseLoc.X - ActiveElement.X; 
                    if (NewSize.Width < 1) 
                        NewSize.Width = 1; 

                    ActiveElement.Size = NewSize; 
                    picCanvas.Invalidate(); 
                    break; 
                case MoveModeType.ResizeBottom: 
                    MouseLoc.Offset(0, -3); 
                    Size NewSize = ActiveElement.Size; 
                    NewSize.Height = MouseLoc.Y - ActiveElement.Y; 
                    if (NewSize.Height < 1) 
                        NewSize.Height = 1; 

                    ActiveElement.Size = NewSize; 
                    picCanvas.Invalidate(); 
                    break; 
                case MoveModeType.ResizeTopLeft: 
                    MouseLoc.Offset(3, 0); 
                    Point BRPoint = new Point(ActiveElement.X + ActiveElement.Width, ActiveElement.Y + ActiveElement.Height); 
                    ActiveElement.Location = MouseLoc; 
                    Size NewSize = ActiveElement.Size; 
                    Point NewLoc = ActiveElement.Location; 
                    NewSize.Width = BRPoint.X - MouseLoc.X; 
                    NewSize.Height = BRPoint.Y - MouseLoc.Y; 
                    if (NewSize.Width < 1) { 
                        NewLoc.X = BRPoint.X - 1; 
                        NewSize.Width = 1; 
                    } 

                    if (NewSize.Height < 1) { 
                        NewLoc.Y = BRPoint.Y - 1; 
                        NewSize.Height = 1; 
                    } 

                    ActiveElement.Size = NewSize; 
                    ActiveElement.Location = NewLoc; 
                    picCanvas.Invalidate(); 
                    break; 
                case MoveModeType.ResizeLeft: 
                    MouseLoc.Offset(3, 0); 
                    Point BRPoint = new Point(ActiveElement.X + ActiveElement.Width, ActiveElement.Y + ActiveElement.Height); 
                    int OldY = ActiveElement.Y; 
                    ActiveElement.Location = MouseLoc; 
                    Size NewSize = ActiveElement.Size; 
                    Point NewLoc = ActiveElement.Location; 
                    NewSize.Width = BRPoint.X - MouseLoc.X; 
                    if (NewSize.Width < 1) { 
                        NewLoc.X = BRPoint.X - 1; 
                        NewSize.Width = 1; 
                    } 

                    NewLoc.Y = OldY; 
                    ActiveElement.Size = NewSize; 
                    ActiveElement.Location = NewLoc; 
                    picCanvas.Invalidate(); 
                    break; 
                case MoveModeType.ResizeTop: 
                    MouseLoc.Offset(0, 3); 
                    Point BRPoint = new Point(ActiveElement.X + ActiveElement.Width, ActiveElement.Y + ActiveElement.Height); 
                    int OldX = ActiveElement.X; 
                    ActiveElement.Location = MouseLoc; 
                    Size NewSize = ActiveElement.Size; 
                    Point NewLoc = ActiveElement.Location; 
                    NewSize.Height = BRPoint.Y - MouseLoc.Y; 
                    if (NewSize.Height < 1) { 
                        NewLoc.Y = BRPoint.Y - 1; 
                        NewSize.Height = 1; 
                    } 

                    NewLoc.X = OldX; 
                    ActiveElement.Size = NewSize; 
                    ActiveElement.Location = NewLoc; 
                    picCanvas.Invalidate(); 
                    break; 
                case MoveModeType.ResizeTopRight: 
                    MouseLoc.Offset(-3, 0); 
                    Point BRPoint = new Point(ActiveElement.X + ActiveElement.Width, ActiveElement.Y + ActiveElement.Height); 
                    Point NewLoc = ActiveElement.Location; 
                    NewLoc.Y = MouseLoc.Y; 
                    ActiveElement.Location = NewLoc; 
                    Size NewSize = ActiveElement.Size; 
                    NewSize.Height = BRPoint.Y - MouseLoc.Y; 
                    NewSize.Width = MouseLoc.X - ActiveElement.X; 
                    if (NewSize.Height < 1) { 
                        NewLoc.Y = BRPoint.Y - 1; 
                        NewSize.Height = 1; 
                    } 

                    if (NewSize.Width < 1) 
                        NewSize.Width = 1; 

                    
                    NewLoc.X = ActiveElement.Location.X; 
                    
                    ActiveElement.Size = NewSize; 
                    ActiveElement.Location = NewLoc; 
                    picCanvas.Invalidate(); 
                    break; 
                case MoveModeType.ResizeBottomLeft: 
                    MouseLoc.Offset(0, -3); 
                    Point BRPoint = new Point(ActiveElement.X + ActiveElement.Width, ActiveElement.Y + ActiveElement.Height); 
                    Point NewLoc = ActiveElement.Location; 
                    NewLoc.X = MouseLoc.X; 
                    ActiveElement.Location = NewLoc; 
                    Size NewSize = ActiveElement.Size; 
                    NewSize.Width = BRPoint.X - MouseLoc.X; 
                    NewSize.Height = MouseLoc.Y - ActiveElement.Y; 
                    if (NewSize.Width < 1) { 
                        NewLoc.X = BRPoint.X - 1; 
                        NewSize.Width = 1; 
                    } 

                    if (NewSize.Height < 1) 
                        NewSize.Height = 1; 

                    NewLoc.Y = ActiveElement.Y; 
                    ActiveElement.Size = NewSize; 
                    ActiveElement.Location = NewLoc; 
                    picCanvas.Invalidate(); 
                    break; 
            } 
        } 
        else { 
            if ((HoverElement != null)) { 
                switch (HoverElement.HitTest(MouseLoc)) { 
                    //choose a cursor based on where the mouse is positioned over an element 
                    case MoveModeType.Move: 
                        this.Cursor = Cursors.SizeAll; 
                        break; 
                    case MoveModeType.ResizeTopLeft: 
                    case MoveModeType.ResizeBottomRight: 
                        this.Cursor = Cursors.SizeNWSE; 
                        break; 
                    case MoveModeType.ResizeTopRight: 
                    case MoveModeType.ResizeBottomLeft: 
                        this.Cursor = Cursors.SizeNESW; 
                        break; 
                    case MoveModeType.ResizeTop: 
                    case MoveModeType.ResizeBottom: 
                        this.Cursor = Cursors.SizeNS; 
                        break; 
                    case MoveModeType.ResizeLeft: 
                    case MoveModeType.ResizeRight: 
                        this.Cursor = Cursors.SizeWE; 
                        break; 
                    default: 
                        this.Cursor = Cursors.Default; 
                        break; 
                } 
            } 
            else { 
                this.Cursor = Cursors.Default; 
            } 
        } 
        LastPos = MouseLoc; 
    } 
    
    private void picCanvas_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e) 
    { 
        Point MouseLoc = new Point(e.X, e.Y); 
        BaseElement ClickedElement = ElementStack.GetElementFromPoint(MouseLoc); 
        ShowSelectionRect = false; 
        
        Cursor.Clip = null; 
        //unlock the cursor 
        
        switch (MoveMode) { 
            case MoveModeType.SelectionBox: 
                BaseElement LastSelected = null; 
                foreach (object o in ElementStack.GetElements) { 
                    BaseElement Element = (BaseElement)o; 
                    if (Element.ContainsTest(SelectionRect)) { 
                        Element.Selected = true; 
                        LastSelected = Element; 
                    } 
                    else { 
                        if (!(bool)Control.ModifierKeys & Keys.Control) { 
                            //if control was held down do not deselect the elements 
                            Element.Selected = false; 
                        } 
                    } 
                } 

                SetActiveElement(LastSelected, false); 
                break; 
            default: 
                break; 
            //SetActiveElement(ClickedElement, True) 
        } 
        
        if (MoveMode != MoveModeType.None && MoveMode != MoveModeType.SelectionBox && ElementChanged) { 
            CreateUndoPoint("Element Moved"); 
            ElementChanged = false; 
        } 
        
        if ((bool)e.Button & MouseButtons.Right) { 
            //If Not ClickedElement Is Nothing AndAlso Not ActiveElement Is Nothing Then 
            ContextMenu Menu = mnuContextMenu; 
            GetContextMenu(ActiveElement, Menu); 
            Menu.Show(picCanvas, MouseLoc); 
            ClearContextMenu(Menu); 
            //End If 
        } 
        SetActiveElement(ActiveElement, false); 
        picCanvas.Invalidate(); 
        MoveMode = MoveModeType.None; 
        mAnchorOffset = new Size(0, 0); 
    } 
    
    private void DesignerForm_FormClosing(object sender, System.Windows.Forms.FormClosingEventArgs e) 
    { 
        if (this.WindowState == FormWindowState.Normal) { 
            My.Settings.DesignerFormSize = this.Size; 
        } 
        else { 
            My.Settings.DesignerFormSize = this.RestoreBounds.Size; 
        } 
        My.Settings.Save(); 
    } 
    
    private void DesignerForm_KeyDown(object sender, System.Windows.Forms.KeyEventArgs e) 
    { 
        if (HookKeyDown != null) { 
            HookKeyDown(ActiveControl, e); 
        } 
        if (!e.Handled) { 
            if (object.ReferenceEquals(ActiveControl, CanvasFocus)) { 
                bool DoRedraw = false; 
                if (e.KeyCode == Keys.Delete || e.KeyCode == Keys.Back) { 
                    DeleteSelectedElements(); 
                    e.Handled = true; 
                    DoRedraw = true; 
                } 
                else if (e.KeyCode == Windows.Forms.Keys.Up) { 
                    foreach (object o in ElementStack.GetSelectedElements) { 
                        Elements.BaseElement Element = (Elements.BaseElement)o; 
                        Point Loc = Element.Location; 
                        Loc.Offset(0, -(int)ArrowKeyDelta); 
                        Element.Location = Loc; 
                    } 
                    ArrowKeyDelta *= (decimal)1.06; 
                    DoRedraw = true; 
                } 
                else if (e.KeyCode == Windows.Forms.Keys.Down) { 
                    foreach (object o in ElementStack.GetSelectedElements) { 
                        Elements.BaseElement Element = (Elements.BaseElement)o; 
                        Point Loc = Element.Location; 
                        Loc.Offset(0, (int)ArrowKeyDelta); 
                        Element.Location = Loc; 
                    } 
                    ArrowKeyDelta *= (decimal)1.06; 
                    DoRedraw = true; 
                } 
                else if (e.KeyCode == Windows.Forms.Keys.Left) { 
                    foreach (object o in ElementStack.GetSelectedElements) { 
                        Elements.BaseElement Element = (Elements.BaseElement)o; 
                        Point Loc = Element.Location; 
                        Loc.Offset(-(int)ArrowKeyDelta, 0); 
                        Element.Location = Loc; 
                    } 
                    ArrowKeyDelta *= (decimal)1.06; 
                    DoRedraw = true; 
                } 
                else if (e.KeyCode == Windows.Forms.Keys.Right) { 
                    foreach (object o in ElementStack.GetSelectedElements) { 
                        Elements.BaseElement Element = (Elements.BaseElement)o; 
                        Point Loc = Element.Location; 
                        Loc.Offset((int)ArrowKeyDelta, 0); 
                        Element.Location = Loc; 
                    } 
                    ArrowKeyDelta *= (decimal)1.06; 
                    DoRedraw = true; 
                } 
                else if (e.KeyCode == Keys.PageDown) { 
                    int Z; 
                    if ((ActiveElement != null)) { 
                        Z = ActiveElement.Z; 
                    } 
                    else { 
                        Z = ElementStack.GetElements.Count - 1; 
                    } 
                    Z -= 1; 
                    if (Z < 0) 
                        Z = ElementStack.GetElements.Count - 1; 
                    if (Z >= 0 & Z <= ElementStack.GetElements.Count - 1) { 
                        SetActiveElement((BaseElement)ElementStack.GetElements(Z), true); 
                    } 
                } 
                else if (e.KeyCode == Keys.PageUp) { 
                    int Z; 
                    if ((ActiveElement != null)) { 
                        Z = ActiveElement.Z; 
                    } 
                    else { 
                        Z = ElementStack.GetElements.Count - 1; 
                    } 
                    Z += 1; 
                    if (Z > ElementStack.GetElements.Count - 1) 
                        Z = 0; 
                    SetActiveElement((BaseElement)ElementStack.GetElements(Z), true); 
                } 
                
                if (ArrowKeyDelta > 10) 
                    ArrowKeyDelta = 10; 
                
                if (DoRedraw) { 
                    picCanvas.Invalidate(); 
                    ElementProperties.SelectedObjects = ElementProperties.SelectedObjects; 
                } 
            } 
        } 
    } 
    #endregion 
    
    #region "Utility" 
    
    public void AddElement(BaseElement Element) 
    { 
        ElementStack.AddElement(Element); 
        //AllElements.Add(Element) 
        Element.Selected = true; 
        SetActiveElement(Element, true); 
        picCanvas.Invalidate(); 
        CreateUndoPoint(Element.Name + " added"); 
    } 
    
    public void SetActiveElement(BaseElement Element, bool DeselectOthers) 
    { 
        if (DeselectOthers) { 
            foreach (object o in ElementStack.GetElements) { 
                ((BaseElement)o).Selected = false; 
            } 
        } 
        if ((!object.ReferenceEquals(ActiveElement, Element))) { 
            RefreshElementList(); 
            ActiveElement = Element; 
            cboElements.SelectedItem = Element; 
            if ((Element != null)) 
                Element.Selected = true; 
        } 
        if (ElementStack.GetSelectedElements.Count > 1) { 
            ElementProperties.SelectedObjects = ElementStack.GetSelectedElements.ToArray; 
        } 
        else if ((Element != null)) { 
            ElementProperties.SelectedObject = Element; 
        } 
        else { 
            ElementProperties.SelectedObject = GumpProperties; 
        } 
    } 
    public void SetActiveElement(BaseElement e) 
    { 
        SetActiveElement(e, false); 
    } 
    public void RefreshElementList() 
    { 
        cboElements.Items.Clear(); 
        cboElements.Items.AddRange(ElementStack.GetElements.ToArray); 
    } 
    public void RefreshView(object sender) 
    { 
        RefreshElementList(); 
        cboElements.SelectedItem = ActiveElement; 
        if (ElementStack.GetSelectedElements.Count > 1) { 
            ElementProperties.SelectedObjects = ElementStack.GetSelectedElements.ToArray; 
        } 
        else { 
            ElementProperties.SelectedObject = ActiveElement; 
        } 
    } 
    
    public void SaveTo(string Path) 
    { 
        StatusBar.Text = "Saving gump..."; 
        //VB serializes event handlers too, since forms are not serializable we need to detach the event before serializing, and then re-attach 
        ElementStack.UpdateParent -= ChangeActiveElementEventHandler; 
        ElementStack.Repaint -= RefreshView; 
        //SetActiveElement(Nothing, True) 
        FileStream s = new FileStream(Path, FileMode.Create); 
        System.Runtime.Serialization.Formatters.Binary.BinaryFormatter Writer = new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter(); 
        //Writer.Serialize(s, ElementStack) 
        Writer.Serialize(s, Stacks); 
        Writer.Serialize(s, GumpProperties); 
        s.Close(); 
        ElementStack.UpdateParent += ChangeActiveElementEventHandler; 
        ElementStack.Repaint += RefreshView; 
        StatusBar.Text = ""; 
    } 
    
    public void LoadFrom(string Path) 
    { 
        StatusBar.Text = "Loading gump..."; 
        FileStream s = null; 
        Stacks.Clear(); 
        TabPager.TabPages.Clear(); 
        try { 
            s = new FileStream(Path, FileMode.Open); 
            //Dim Reader As New System.Runtime.Serialization.Formatters.Binary.BinaryFormatter 
            System.Runtime.Serialization.Formatters.Binary.BinaryFormatter Reader = new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter(); 
            Stacks = (ArrayList)Reader.Deserialize(s); 
            try { 
                GumpProperties = (Elements.GumpProperties)Reader.Deserialize(s); 
            } 
            catch (Exception ex) { 
                GumpProperties = new GumpProperties(); 
                Interaction.MsgBox(ex.InnerException.Message); 
            } 
            SetActiveElement(null, true); 
            //deselect all elements 
            RefreshElementList(); 
        } 
        catch (Exception ex) { 
            Interaction.MsgBox(ex.Message); 
        } 
        finally { 
            if (s != null) 
                s.Close(); 
        } 
        int Counter = 0; 
        foreach (object o in Stacks) { 
            TabPager.TabPages.Add(new TabPage(Counter.ToString)); 
            Counter += 1; 
        } 
        ChangeActiveStack(0); 
        //add the event handler 
        ElementStack.UpdateParent += ChangeActiveElementEventHandler; 
        ElementStack.Repaint += RefreshView; 
        StatusBar.Text = ""; 
    } 
    
    protected Rectangle GetPositiveRect(Rectangle Rect) 
    { 
        if (Rect.Height < 0) { 
            Rect.Height = Math.Abs(Rect.Height); 
            Rect.Y = Rect.Y - Rect.Height; 
        } 
        if (Rect.Width < 0) { 
            Rect.Width = Math.Abs(Rect.Width); 
            Rect.X = Rect.X - Rect.Width; 
        } 
        return Rect; 
    } 
    
    public BaseElement GetLastSelectedControl() 
    { 
        BaseElement ret = null; 
        foreach (object o in ElementStack.GetElements) { 
            BaseElement Element = (BaseElement)o; 
            ret = Element; 
        } 
        return ret; 
    } 
    
    protected void DeleteSelectedElements() 
    { 
        ArrayList el = new ArrayList(); 
        el.AddRange(ElementStack.GetElements); 
        bool Deleted = false; 
        foreach (object o in el) { 
            Deleted = true; 
            BaseElement Element = (BaseElement)o; 
            if (Element.Selected) { 
                ElementStack.RemoveElement(Element); 
            } 
        } 
        SetActiveElement(this.GetLastSelectedControl); 
        picCanvas.Invalidate(); 
        if (Deleted) 
            CreateUndoPoint("Delete Elements"); 
    } 
    
    public void ChangeActiveStack(int StackID) 
    { 
        if (StackID <= Stacks.Count - 1) { 
            SetActiveElement(null, true); 
            if ((ElementStack != null)) { 
                ElementStack.UpdateParent -= ChangeActiveElementEventHandler; 
                ElementStack.Repaint -= RefreshView; 
            } 
            ElementStack = (GroupElement)Stacks(StackID); 
            ElementStack.UpdateParent += ChangeActiveElementEventHandler; 
            ElementStack.Repaint += RefreshView; 
            picCanvas.Invalidate(); 
        } 
    } 
    
    protected void ChangeActiveElementEventHandler(BaseElement e, bool DeselectOthers) 
    { 
        SetActiveElement(e, DeselectOthers); 
        picCanvas.Invalidate(); 
    } 
    
    protected void BuildToolbox() 
    { 
        pnlToolbox.Controls.Clear(); 
        int YPos; 
        foreach (object o in RegisteredTypes) { 
            Type t = (Type)o; 
            BaseElement Element = (BaseElement)Activator.CreateInstance(t); 
            Button b = new Button(); 
            b.Text = Element.Type; 
            b.Location = new Point(0, YPos); 
            b.FlatStyle = FlatStyle.System; 
            b.Width = pnlToolbox.Width; 
            b.Anchor = AnchorStyles.Left | AnchorStyles.Right | AnchorStyles.Top; 
            b.Tag = t; 
            YPos += b.Height - 1; 
            pnlToolbox.Controls.Add(b); 
            b.Click += CreateElementFromToolbox; 
            
            //Get Aboutbox info 
            if (Element.DispayInAbout) { 
                AboutElementAppend // ERROR: Unknown assignment operator ConcatString ; 
            } 
            
            //Let all loaded plugins attach Element extenders if they want to 
            foreach (object o1 in LoadedPlugins) { 
                Plugins.BasePlugin Plugin = (Plugins.BasePlugin)o1; 
                Plugin.InitializeElementExtenders(Element); 
            } 
        } 
        BaseElement.ResetID(); 
        
        //Load gumplingTree 
        GumplingTree = new TreeFolder("Root"); 
        GumplingsFolder = new TreeFolder("My Gumplings"); 
        UncategorizedFolder = new TreeFolder("Uncategorized"); 
        GumplingTree.AddItem(GumplingsFolder); 
        GumplingTree.AddItem(UncategorizedFolder); 
        BuildGumplingTree(); 
    } 
    
    public void BuildGumplingTree() 
    { 
        treGumplings.Nodes.Clear(); 
        BuildGumplingTree(GumplingTree, null); 
    } 
    public void BuildGumplingTree(TreeFolder Item, TreeNode Node) 
    { 
        foreach (object o in Item.GetChildren) { 
            TreeItem Subitem = (TreeItem)o; 
            TreeNode NewNode = new TreeNode(); 
            NewNode.Text = Subitem.Text; 
            NewNode.Tag = Subitem; 
            if (Node == null) { 
                treGumplings.Nodes.Add(NewNode); 
            } 
            else { 
                Node.Nodes.Add(NewNode); 
            } 
            if (Subitem is TreeFolder) { 
                BuildGumplingTree((TreeFolder)Subitem, NewNode); 
            } 
        } 
    } 
    
    public void CreateElementFromToolbox(object sender, System.EventArgs e) 
    { 
        Button b = (Button)sender; 
        BaseElement Element = (BaseElement)Activator.CreateInstance((Type)b.Tag); 
        AddElement(Element); 
        picCanvas.Invalidate(); 
        picCanvas.Focus(); 
    } 
    
    protected void GetContextMenu(ref BaseElement Element, ContextMenu Menu) 
    { 
        MenuItem GroupMenu = new MenuItem("Grouping"); 
        MenuItem PositionMenu = new MenuItem("Positioning"); 
        MenuItem OrderMenu = new MenuItem("Order"); 
        MenuItem MiscMenu = new MenuItem("Misc"); 
        MenuItem EditMenu = new MenuItem("Edit"); 
        
        //Commented out because it causes the undo/redo intems in teh main menu to go away 
        //EditMenu.MenuItems.Add(Me.mnuEditUndo) 
        //EditMenu.MenuItems.Add(Me.mnuEditRedo) 
        //EditMenu.MenuItems.Add(New MenuItem("-")) '-------- 
        EditMenu.MenuItems.Add(new MenuItem("Cut", mnuCut_Click)); 
        EditMenu.MenuItems.Add(new MenuItem("Copy", mnuCopy_Click)); 
        EditMenu.MenuItems.Add(new MenuItem("Paste", mnuPaste_Click)); 
        EditMenu.MenuItems.Add(new MenuItem("Delete", mnuDelete_Click)); 
        
        Menu.MenuItems.Add(EditMenu); 
        Menu.MenuItems.Add(new MenuItem("-")); 
        //-------- 
        Menu.MenuItems.Add(GroupMenu); 
        Menu.MenuItems.Add(PositionMenu); 
        Menu.MenuItems.Add(OrderMenu); 
        Menu.MenuItems.Add(new MenuItem("-")); 
        //--------- 
        Menu.MenuItems.Add(MiscMenu); 
        
        if (ElementStack.GetSelectedElements.Count >= 2) 
            GroupMenu.MenuItems.Add(new MenuItem("Create Group", mnuGroupCreate_Click)); 
        if ((Element != null)) 
            Element.AddContextMenus(GroupMenu, PositionMenu, OrderMenu, MiscMenu); 
        if (GroupMenu.MenuItems.Count == 0) 
            GroupMenu.Enabled = false; 
        if (PositionMenu.MenuItems.Count == 0) 
            PositionMenu.Enabled = false; 
        if (OrderMenu.MenuItems.Count == 0) 
            OrderMenu.Enabled = false; 
        if (MiscMenu.MenuItems.Count == 0) 
            MiscMenu.Enabled = false; 
    } 
    
    public void ClearContextMenu(Menu Menu) 
    { 
        for (int counter = 0; counter <= Menu.MenuItems.Count - 1; counter++) { 
            MenuItem m = Menu.MenuItems(0); 
            Menu.MenuItems.RemoveAt(0); 
        } 
    } 
    
    public Point SnapLocToGrid(Point Position, Size GridSize) 
    { 
        Point NewPoint = Position; 
        NewPoint.X = (int)NewPoint.X / GridSize.Width * GridSize.Width; 
        NewPoint.Y = (int)NewPoint.Y / GridSize.Height * GridSize.Height; 
        return NewPoint; 
    } 
    
    public void Cut() 
    { 
        ArrayList Elements = new ArrayList(); 
        foreach (object o in ElementStack.GetSelectedElements) { 
            BaseElement Element = (BaseElement)o; 
            Elements.Add(Element); 
        } 
        Clipboard.SetDataObject(Elements); 
        DeleteSelectedElements(); 
        CopyMode = ClipBoardMode.Cut; 
    } 
    
    public void Copy() 
    { 
        ArrayList Elements = new ArrayList(); 
        foreach (object o in ElementStack.GetSelectedElements) { 
            BaseElement Element = (BaseElement)o; 
            Elements.Add(Element.Clone); 
        } 
        Clipboard.SetDataObject(Elements); 
        CopyMode = ClipBoardMode.Copy; 
    } 
    
    public void Paste() 
    { 
        IDataObject Data = Clipboard.GetDataObject; 
        ArrayList Elements = new ArrayList(); 
        Elements = (ArrayList)Data.GetData(typeof(ArrayList)); 
        if ((Elements != null)) { 
            SetActiveElement(null, true); 
            foreach (object o in Elements) { 
                BaseElement Element = (BaseElement)o; 
                if (CopyMode == ClipBoardMode.Copy) 
                    Element.Name = "Copy of " + Element.Name; 
                Element.Selected = true; 
                ElementStack.AddElement(Element); 
            } 
        } 
        picCanvas.Invalidate(); 
    } 
    
    public void ClearGump() 
    { 
        TabPager.TabPages.Clear(); 
        TabPager.TabPages.Add(new TabPage("0")); 
        Stacks.Clear(); 
        BaseElement.ResetID(); 
        ElementStack = new Elements.GroupElement(null, null, "Element Stack", true); 
        Stacks.Add(ElementStack); 
        GumpProperties = new GumpProperties(); 
        ElementStack.UpdateParent += ChangeActiveElementEventHandler; 
        ElementStack.Repaint += RefreshView; 
        SetActiveElement(null); 
        picCanvas.Invalidate(); 
        FileName = ""; 
        this.Text = "Gump Studio (-Unsaved Gump-)"; 
        ChangeActiveStack(0); 
        UndoPoints = new ArrayList(); 
        CreateUndoPoint("Blank"); 
        mnuEditUndo.Enabled = false; 
        mnuEditRedo.Enabled = false; 
    } 
    
    public int AddPage() 
    { 
        Elements.GroupElement Stack = new Elements.GroupElement(null, null, "CanvasStack", true); 
        Stacks.Add(Stack); 
        TabPage NewPage = new TabPage((string)Stacks.Count - 1); 
        TabPager.TabPages.Add(NewPage); 
        TabPager.SelectedIndex = Stacks.Count - 1; 
        ChangeActiveStack(Stacks.Count - 1); 
        return Stacks.Count - 1; 
    } 
    
    public void RebuildTabPages() 
    { 
        TabPager.TabPages.Clear(); 
        int Counter = -1; 
        foreach (object o in Stacks) { 
            Counter += 1; 
            TabPage NewPage = new TabPage((string)Counter); 
            TabPager.TabPages.Add(NewPage); 
            if (object.ReferenceEquals(ElementStack, o)) 
                TabPager.SelectedIndex = Counter; 
        } 
    } 
    
    public void SelectAll() 
    { 
        foreach (object o in ElementStack.GetSelectedElements) { 
            BaseElement Element = (BaseElement)o; 
            Element.Selected = true; 
        } 
        picCanvas.Invalidate(); 
    } 
    
    public void CreateUndoPoint(string Action) 
    { 
        
        
        //save the current state into a new undo point so that it can be undone later 
        //All UndoPoints after CurrentUndoPoint will be lost 
        //only the last x undopoint are saved 
        if (!SuppressUndoPoints) { 
            System.Diagnostics.Stopwatch s = new System.Diagnostics.Stopwatch(); 
            s.Start(); 
            while (CurrentUndoPoint < UndoPoints.Count - 1) { 
                UndoPoint mup = (UndoPoint)UndoPoints(CurrentUndoPoint + 1); 
                UndoPoints.RemoveAt(CurrentUndoPoint + 1); 
                Debug.WriteLine("removing undopoint " + mup.Text); 
            } 
            UndoPoint up = new UndoPoint(this); 
            up.Text = Action; 
            if (UndoPoints.Count > MaxUndoPoints) { 
                UndoPoints.RemoveAt(0); 
            } 
            UndoPoints.Add(up); 
            CurrentUndoPoint = UndoPoints.Count - 1; 
            mnuEditUndo.Enabled = true; 
            mnuEditRedo.Enabled = false; 
            s.Stop(); 
            Debug.WriteLine("Created undo point " + CurrentUndoPoint + 1 + " in " + s.Elapsed.ToString); 
        } 
    } 
    public void CreateUndoPoint() 
    { 
        this.CreateUndoPoint("Unknown Action"); 
    } 
    
    public void Undo() 
    { 
        //Revert state back to a previously saved UndoPoint 
        CurrentUndoPoint -= 1; 
        RevertToUndoPoint(CurrentUndoPoint); 
        if (CurrentUndoPoint == 0) 
            mnuEditUndo.Enabled = false; 
        mnuEditRedo.Enabled = true; 
    } 
    public void Redo() 
    { 
        if (CurrentUndoPoint < UndoPoints.Count) { 
            CurrentUndoPoint += 1; 
            RevertToUndoPoint(CurrentUndoPoint); 
        } 
        if (CurrentUndoPoint == UndoPoints.Count - 1) 
            mnuEditRedo.Enabled = false; 
        mnuEditUndo.Enabled = true; 
    } 
    
    public void RevertToUndoPoint(int Index) 
    { 
        UndoPoint up = (UndoPoint)UndoPoints(Index); 
        GumpProperties = (GumpProperties)up.GumpProperties.Clone; 
        Stacks = new ArrayList(); 
        foreach (object o in up.Stack) { 
            GroupElement g = (GroupElement)o; 
            GroupElement ng = (GroupElement)g.Clone; 
            Stacks.Add(ng); 
            if (object.ReferenceEquals(up.ElementStack, g)) 
                ElementStack = ng; 
        } 
        RebuildTabPages(); 
        Debug.WriteLine("Restored to undo point: " + Index + 1); 
        picCanvas.Invalidate(); 
        SetActiveElement(null, true); 
        CurrentUndoPoint = Index; 
    } 
    
    #endregion 
    
    #region "Menu Handlers" 
    private void mnuFileSave_Click(object sender, System.EventArgs e) 
    { 
        SaveDialog.AddExtension = true; 
        SaveDialog.DefaultExt = "gump"; 
        SaveDialog.Filter = "Gump|*.gump"; 
        if (SaveDialog.ShowDialog == DialogResult.OK) { 
            SaveTo(SaveDialog.FileName); 
            FileName = Path.GetFileName(SaveDialog.FileName); 
            this.Text = "Gump Studio (" + FileName + ")"; 
        } 
    } 
    
    private void mnuFileOpen_Click(object sender, System.EventArgs e) 
    { 
        OpenDialog.CheckFileExists = true; 
        OpenDialog.Filter = "Gump|*.gump"; 
        if (OpenDialog.ShowDialog == DialogResult.OK) { 
            LoadFrom(OpenDialog.FileName); 
            FileName = Path.GetFileName(OpenDialog.FileName); 
            this.Text = "Gump Studio (" + FileName + ")"; 
        } 
        picCanvas.Invalidate(); 
    } 
    
    private void mnuFileNew_Click(object sender, System.EventArgs e) 
    { 
        if (Interaction.MsgBox("Are you sure you want to start a new gump?", MsgBoxStyle.Question | MsgBoxStyle.YesNo) == MsgBoxResult.Yes) { 
            ClearGump(); 
        } 
    } 
    
    private void mnuGroupCreate_Click(object sender, System.EventArgs e) 
    { 
        ArrayList es = new ArrayList(); 
        foreach (object o in ElementStack.GetElements) { 
            BaseElement Element = (BaseElement)o; 
            if (Element.Selected) { 
                es.Add(Element); 
            } 
        } 
        if (es.Count >= 2) { 
            Elements.GroupElement Group = new Elements.GroupElement(ElementStack, null, "New Group"); 
            foreach (object o in es) { 
                BaseElement Element = (BaseElement)o; 
                Group.AddElement(Element); 
                ElementStack.RemoveElement(Element); 
                ElementStack.RemoveEvents(Element); 
            } 
            AddElement(Group); 
            
            picCanvas.Invalidate(); 
        } 
        CreateUndoPoint(); 
    } 
    
    private void mnuDelete_Click(object sender, System.EventArgs e) 
    { 
        DeleteSelectedElements(); 
    } 
    
    private void mnuFileExit_Click(object sender, System.EventArgs e) 
    { 
        this.Close(); 
    } 
    
    private void MenuItem2_Click(object sender, System.EventArgs e) 
    { 
        OpenDialog.Filter = "Gumpling (*.gumpling)|*.gumpling|Gump (*.gump)|*.gump"; 
        if (OpenDialog.ShowDialog == DialogResult.OK) { 
            GroupElement group; 
            FileStream s = new FileStream(OpenDialog.FileName, FileMode.Open); 
            System.Runtime.Serialization.Formatters.Binary.BinaryFormatter Reader = new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter(); 
            group = (GroupElement)Reader.Deserialize(s); 
            group.mIsBaseWindow = false; 
            group.RecalculateBounds(); 
            group.Location = new Point(0, 0); 
            s.Close(); 
            AddElement(group); 
        } 
    } 
    
    
    private void mnuPluginManager_Click(object sender, System.EventArgs e) 
    { 
        PluginManager f = new PluginManager(); 
        f.AvailablePlugins = AvailablePlugins; 
        f.LoadedPlugins = LoadedPlugins; 
        f.OrderList = PluginTypesToLoad; 
        f.MainForm = this; 
        f.ShowDialog(); 
    } 
    
    
    private void mnuAddPage_Click(object sender, System.EventArgs e) 
    { 
        AddPage(); 
        CreateUndoPoint("Add page"); 
    } 
    
    private void mnuPageClear_Click(object sender, System.EventArgs e) 
    { 
        ElementStack = new Elements.GroupElement(null, null, "Element Stack", true); 
        CreateUndoPoint("Clear Page"); 
    } 
    
    private void mnuHelpAbout_Click(object sender, System.EventArgs e) 
    { 
        frmAboutBox f = new frmAboutBox(); 
        f.SetText(AboutElementAppend); 
        f.ShowDialog(); 
    } 
    
    private void mnuCopy_Click(object sender, System.EventArgs e) 
    { 
        Copy(); 
    } 
    
    private void mnuPaste_Click(object sender, System.EventArgs e) 
    { 
        Paste(); 
        CreateUndoPoint(); 
    } 
    
    private void mnuCut_Click(object sender, System.EventArgs e) 
    { 
        Cut(); 
        CreateUndoPoint(); 
    } 
    
    private void mnuSelectAll_Click(object sender, System.EventArgs e) 
    { 
        SelectAll(); 
    } 
    
    private void mnuEditUndo_Click(object sender, System.EventArgs e) 
    { 
        Undo(); 
    } 
    
    private void mnuEditRedo_Click(object sender, System.EventArgs e) 
    { 
        Redo(); 
    } 
    #endregion 
    
    #region "Plugins" 
    
    protected void EnumeratePlugins() 
    { 
        if (!Directory.Exists(Application.StartupPath + "\\Plugins")) { 
            Directory.CreateDirectory(Application.StartupPath + "\\Plugins"); 
        } 
        
        PluginTypesToLoad = GetPluginsToLoad(); 
        
        Debug.WriteLine("Enumerating Plugins"); 
        Debug.Indent(); 
        foreach (string FileName in Directory.GetFiles(Application.StartupPath + "\\Plugins", "*.dll")) { 
            Debug.WriteLine(Path.GetFileName(FileName)); 
            Assembly asm; 
            asm = Reflection.Assembly.LoadFile(FileName); 
            Debug.Indent(); 
            foreach (Type t in asm.GetTypes) { 
                try { 
                    if (t.IsSubclassOf(typeof(Plugins.BasePlugin)) & !t.IsAbstract) { 
                        Plugins.BasePlugin p = (Plugins.BasePlugin)Activator.CreateInstance(t); 
                        //Add plugin info to about box text 
                        Plugins.PluginInfo Info = p.GetPluginInfo; 
                        AboutElementAppend // ERROR: Unknown assignment operator ConcatString ; 
                        AvailablePlugins.Add(p); 
                    } 
                    if (t.IsSubclassOf(typeof(BaseElement))) { 
                        RegisteredTypes.Add(t); 
                    } 
                } 
                catch (Exception ex) { 
                    Interaction.MsgBox("Error loading plugin: " + t.Name + "(" + FileName + ")" + Constants.vbNewLine + Constants.vbNewLine + ex.Message); 
                } 
            } 
            Debug.Unindent(); 
        } 
        Debug.Unindent(); 
        Debug.WriteLine("Loading plugins"); 
        if ((PluginTypesToLoad != null)) { 
            foreach (Plugins.PluginInfo PInfo in PluginTypesToLoad) { 
                foreach (object o in AvailablePlugins) { 
                    Plugins.BasePlugin Plugin = (Plugins.BasePlugin)o; 
                    Plugins.PluginInfo Info = Plugin.GetPluginInfo; 
                    if (PInfo.Equals(Info)) { 
                        Plugin.Load(this); 
                        LoadedPlugins.Add(Plugin); 
                    } 
                } 
            } 
        } 
        
        //For Each o As Object In LoadedPlugins 
        // Dim Plugin As Plugins.BasePlugin = CType(o, Plugins.BasePlugin) 
        // If Not plugin.IsLoaded Then 
        // plugin.Load(Me) 
        // If PluginTypesToLoad Is Nothing Then 
        // ReDim PluginTypesToLoad(0) 
        // Else 
        // ReDim Preserve PluginTypesToLoad(LoadedPlugins.Count) 
        // End If 
        // PluginTypesToLoad(PluginTypesToLoad.Length - 1) = plugin.GetPluginInfo 
        // End If 
        //Next 
    } 
    
    protected Plugins.PluginInfo[] GetPluginsToLoad() 
    { 
        Plugins.PluginInfo[] Types = null; 
        if (File.Exists(Application.StartupPath + "\\Plugins\\LoadInfo")) { 
            FileStream s; 
            s = new FileStream(Application.StartupPath + "\\Plugins\\LoadInfo", FileMode.Open); 
            System.Runtime.Serialization.Formatters.Binary.BinaryFormatter Reader = new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter(); 
            Types = (Plugins.PluginInfo[])Reader.Deserialize(s); 
            s.Close(); 
        } 
        return Types; 
    } 
    
    public void WritePluginsToLoad() 
    { 
        if ((PluginTypesToLoad != null)) { 
            FileStream s = new FileStream(Application.StartupPath + "\\Plugins\\LoadInfo", FileMode.Create); 
            System.Runtime.Serialization.Formatters.Binary.BinaryFormatter Writer = new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter(); 
            Writer.Serialize(s, PluginTypesToLoad); 
            s.Close(); 
        } 
        else { 
            if (File.Exists(Application.StartupPath + "\\Plugins\\LoadInfo")) 
                File.Delete(Application.StartupPath + "\\Plugins\\LoadInfo"); 
        } 
    } 
    #endregion 
    
    #region "Event Procedures" 
    
    private void cboElements_Click(object sender, System.EventArgs e) 
    { 
        foreach (object o in ElementStack.GetElements) { 
            BaseElement Element = (BaseElement)o; 
            Element.Selected = false; 
        } 
        ActiveElement = null; 
    } 
    
    private void DesignerForm_Closed(object sender, System.EventArgs e) 
    { 
        if (SelFG != null) 
            SelFG.Dispose(); 
        if (SelBG != null) 
            SelBG.Dispose(); 
        WritePluginsToLoad(); 
    } 
    
    private void ElementProperties_PropertyValueChanged(object s, System.Windows.Forms.PropertyValueChangedEventArgs e) 
    { 
        if (e.ChangedItem.PropertyDescriptor.Name == "Name") { 
            cboElements.Items.Clear(); 
            cboElements.Items.AddRange(ElementStack.GetElements.ToArray); 
            cboElements.SelectedItem = ElementProperties.SelectedObject; 
        } 
        picCanvas.Invalidate(); 
        CreateUndoPoint("Property Changed"); 
    } 
    
    private void cboElements_SelectedIndexChanged(object sender, System.EventArgs e) 
    { 
        SetActiveElement((BaseElement)cboElements.SelectedItem, false); 
        picCanvas.Invalidate(); 
    } 
    
    private void TabPager_SelectedIndexChanged(object sender, System.EventArgs e) 
    { 
        if (TabPager.SelectedIndex != -1) { 
            ChangeActiveStack(TabPager.SelectedIndex); 
        } 
        RefreshElementList(); 
    } 
    
    private void pnlCanvasScroller_MouseLeave(object sender, System.EventArgs e) 
    { 
        this.Cursor = Cursors.Default; 
    } 
    
    private void mnuPageDelete_Click(object sender, System.EventArgs e) 
    { 
        if (TabPager.SelectedIndex == 0) { 
            Interaction.MsgBox("Page 0 can not be deleted."); 
        } 
        else { 
            int PageToRemove = TabPager.SelectedIndex; 
            for (int counter = PageToRemove + 1; counter <= TabPager.TabCount - 1; counter++) { 
                TabPager.TabPages(counter).Text = (string)counter - 1; 
            } 
            Stacks.RemoveAt(PageToRemove); 
            TabPager.TabPages.RemoveAt(PageToRemove); 
            ChangeActiveStack(PageToRemove - 1); 
            CreateUndoPoint("Delete page"); 
        } 
    } 
    
    private void mnuShow0_Click(object sender, System.EventArgs e) 
    { 
        ShowPage0 = !ShowPage0; 
        mnuShow0.Checked = ShowPage0; 
        picCanvas.Refresh(); 
    } 
    
    private void mnuPageInsert_Click(object sender, System.EventArgs e) 
    { 
        if (TabPager.SelectedIndex == 0) { 
            Interaction.MsgBox("Page 0 may not be moved."); 
        } 
        else { 
            int PageCount = TabPager.TabCount; 
            int PageToMove = TabPager.SelectedIndex; 
            for (int counter = PageToMove; counter <= TabPager.TabCount - 1; counter++) { 
                TabPager.TabPages.RemoveAt(PageToMove); 
            } 
            TabPage NewPage = new TabPage(PageToMove.ToString); 
            TabPager.TabPages.Add(NewPage); 
            for (int counter = PageToMove + 1; counter <= PageCount; counter++) { 
                NewPage = new TabPage(counter.ToString); 
                TabPager.TabPages.Add(NewPage); 
            } 
            GroupElement Stack = new GroupElement(null, null, "Element Stack", true); 
            Stacks.Insert(PageToMove, Stack); 
            ChangeActiveStack(PageToMove); 
            TabPager.SelectedIndex = PageToMove; 
            CreateUndoPoint("Insert page"); 
        } 
    } 
    
    private void DesignerForm_Closing(object sender, System.ComponentModel.CancelEventArgs e) 
    { 
        foreach (object o in AvailablePlugins) { 
            Plugins.BasePlugin Plugin = (Plugins.BasePlugin)o; 
            if (Plugin.IsLoaded) 
                Plugin.Unload(); 
        } 
    } 
    
    private void DesignerForm_KeyUp(object sender, System.Windows.Forms.KeyEventArgs e) 
    { 
        if (e.KeyCode == Windows.Forms.Keys.Up || e.KeyCode == Windows.Forms.Keys.Down || e.KeyCode == Windows.Forms.Keys.Left || e.KeyCode == Windows.Forms.Keys.Right) { 
            CreateUndoPoint("Move element"); 
            ArrowKeyDelta = 1; 
        } 
    } 
    
    
    private void DesignerForm_Load(object sender, System.EventArgs e) 
    { 
        if (My.Settings.ClientPath == "") 
            My.Settings.Upgrade(); 
        if (!File.Exists(Path.Combine(My.Settings.ClientPath, "art.mul"))) { 
            FolderBrowserDialog f = new FolderBrowserDialog(); 
            f.SelectedPath = My.Computer.FileSystem.SpecialDirectories.ProgramFiles; 
            f.Description = "Select the folder that contains the UO data (.mul) files you want to use."; 
            if (f.ShowDialog == Windows.Forms.DialogResult.OK) { 
                if (File.Exists(Path.Combine(f.SelectedPath, "art.mul"))) { 
                    My.Settings.ClientPath = f.SelectedPath; 
                    My.Settings.Save(); 
                } 
                else { 
                    Interaction.MsgBox("This path does not contain a file named \"art.mul\", it is most likely not the correct path. Gump Studio can not run without valid client data files.", MsgBoxStyle.OkOnly, "Data Files"); 
                    this.Close(); 
                    return; // TODO: might not be correct. Was : Exit Sub 
                } 
            } 
            else { 
                this.Close(); 
                return; // TODO: might not be correct. Was : Exit Sub 
            } 
        } 
        
        Ultima.Client.ManualPath = My.Settings.ClientPath; 
        this.Size = My.Settings.DesignerFormSize; 
        MaxUndoPoints = My.Settings.UndoLevels; 
        
        picCanvas.Width = 800; 
        picCanvas.Height = 600; 
        this.CenterToScreen(); 
        frmSplash.DisplaySplash(); 
        EnumeratePlugins(); 
        Canvas = new Bitmap(picCanvas.Width, picCanvas.Height, Imaging.PixelFormat.Format32bppRgb); 
        this.Activate(); 
        
        GumpProperties = new GumpProperties(); 
        ElementStack.UpdateParent += ChangeActiveElementEventHandler; 
        ElementStack.Repaint += RefreshView; 
        Stacks.Clear(); 
        Stacks.Add(ElementStack); 
        ChangeActiveStack(0); 
        
        //Register all element types 
        RegisteredTypes.Clear(); 
        RegisteredTypes.Add(typeof(LabelElement)); 
        RegisteredTypes.Add(typeof(ImageElement)); 
        RegisteredTypes.Add(typeof(TiledElement)); 
        RegisteredTypes.Add(typeof(BackgroundElement)); 
        RegisteredTypes.Add(typeof(AlphaElement)); 
        RegisteredTypes.Add(typeof(CheckboxElement)); 
        RegisteredTypes.Add(typeof(RadioElement)); 
        RegisteredTypes.Add(typeof(ItemElement)); 
        RegisteredTypes.Add(typeof(TextEntryElement)); 
        RegisteredTypes.Add(typeof(ButtonElement)); 
        RegisteredTypes.Add(typeof(HTMLElement)); 
        BuildToolbox(); 
        
        SelFG = new Pen(Color.Blue, 2); 
        Rectangle BrushRect = new Rectangle(0, 0, 50, 50); 
        SelBG = new Drawing2D.LinearGradientBrush(BrushRect, Color.FromArgb(90, Color.Blue), Color.FromArgb(110, Color.Blue), Drawing2D.LinearGradientMode.ForwardDiagonal); 
        SelBG.WrapMode = Drawing2D.WrapMode.TileFlipXY; 
        CreateUndoPoint("Blank"); 
        mnuEditUndo.Enabled = false; 
    } 
    
    #endregion 
    
    private void mnuImportGumpling_Click(object sender, System.EventArgs e) 
    { 
        OpenDialog.Filter = "Gumpling (*.gumpling)|*.gumpling|Gump (*.gump)|*.gump"; 
        if (OpenDialog.ShowDialog == DialogResult.OK) { 
            GroupElement group; 
            FileStream s = new FileStream(OpenDialog.FileName, FileMode.Open); 
            System.Runtime.Serialization.Formatters.Binary.BinaryFormatter Reader = new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter(); 
            group = (GroupElement)Reader.Deserialize(s); 
            group.mIsBaseWindow = false; 
            group.RecalculateBounds(); 
            group.Location = new Point(0, 0); 
            s.Close(); 
            
            UncategorizedFolder.AddItem(new TreeGumpling(Path.GetFileName(OpenDialog.FileName), group)); 
            BuildGumplingTree(); 
        } 
    } 
    
    private void treGumplings_DoubleClick(object sender, System.EventArgs e) 
    { 
        if (((treGumplings.SelectedNode.Tag) != null)) { 
            if (treGumplings.SelectedNode.Tag is TreeGumpling) { 
                TreeGumpling Item = (TreeGumpling)treGumplings.SelectedNode.Tag; 
                GroupElement element = (GroupElement)Item.Gumpling.Clone; 
                
                element.mIsBaseWindow = false; 
                element.RecalculateBounds(); 
                element.Location = new Point(0, 0); 
                AddElement(element); 
            } 
        } 
    } 
    
    private void treGumplings_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e) 
    { 
        treGumplings.SelectedNode = treGumplings.GetNodeAt(new Point(e.X, e.Y)); 
    } 
    
    private void mnuDataFile_Click(object sender, System.EventArgs e) 
    { 
        FolderBrowserDialog f = new FolderBrowserDialog(); 
        f.Description = "Select the folder that contains the UO data (.mul) files you want to use."; 
        if (f.ShowDialog == Windows.Forms.DialogResult.OK) { 
            if (File.Exists(Path.Combine(f.SelectedPath, "art.mul"))) { 
                My.Settings.ClientPath = f.SelectedPath; 
                My.Settings.Save(); 
                Interaction.MsgBox("New path set, please restart Gump Studio to activate your changes.", MsgBoxStyle.OkOnly, "Data Files"); 
            } 
            else { 
                Interaction.MsgBox("This path does not contain a file named \"art.mul\", it is most likely not the correct path.", MsgBoxStyle.OkOnly, "Data Files"); 
            } 
        } 
    } 
} 

public class UndoPoint 
{ 
    public string Text; 
    public GumpProperties GumpProperties; 
    public ArrayList Stack = new ArrayList(); 
    public GroupElement ElementStack; 
    
    public UndoPoint(DesignerForm Designer) 
    { 
        GumpProperties = (GumpProperties)Designer.GumpProperties.Clone; 
        foreach (object o in Designer.Stacks) { 
            GroupElement e = (GroupElement)o; 
            GroupElement ClonedStack = (GroupElement)e.Clone; 
            Stack.Add(ClonedStack); 
            if (object.ReferenceEquals(e, Designer.ElementStack)) 
                ElementStack = ClonedStack; 
        } 
    } 
} 

public enum MoveModeType : int 
{ 
    None = 0, 
    SelectionBox = 1, 
    ResizeTopLeft = 2, 
    ResizeTopRight = 3, 
    ResizeBottomRight = 4, 
    ResizeBottomLeft = 5, 
    Move = 6, 
    ResizeLeft = 7, 
    ResizeTop = 8, 
    ResizeRight = 9, 
    ResizeBottom = 10 
} 

public enum ClipBoardMode : int 
{ 
    Cut = 0, 
    Copy = 1 
} -->
